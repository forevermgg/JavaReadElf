## 程序头部表（Program Header Table)
程序头部表（`Program Header Table`）是`ELF`（可执行和可链接格式）文件中的一个重要部分。它是一个固定大小的表格，包含了描述可执行文件中各个段（`segment`）的加载和执行信息。

每个程序头部表条目（`Program Header Entry`）对应一个段，描述了该段在内存中的位置、大小、属性等信息。

`Elf64_Phdr` 是用于表示 `ELF`（可执行和可链接格式）文件中的程序头部表（`Program Header Table`）条目的结构体。它是一个 `64`位的结构体，包含以下字段：

```c++
typedef struct {
Elf64_Word p_type;        // 段类型
Elf64_Word p_flags;       // 段标志
Elf64_Off p_offset;       // 段在文件中的偏移量
Elf64_Addr p_vaddr;       // 段在内存中的虚拟地址
Elf64_Addr p_paddr;       // 段在物理内存中的物理地址（保留）
Elf64_Xword p_filesz;     // 段在文件中的大小
Elf64_Xword p_memsz;      // 段在内存中的大小
Elf64_Xword p_align;      // 段在内存中的对齐方式
} Elf64_Phdr;
```
程序头部表条目中的字段包括段类型、段标志、段在文件中的偏移量、段在内存中的虚拟地址、段在文件中的大小、段在内存中的大小以及段在内存中的对齐方式等。

程序头部表的主要作用是告诉操作系统或加载器如何加载和执行可执行文件中的各个段。通过解析程序头部表，操作系统或加载器可以正确地将每个段加载到内存，并设置适当的内存保护和访问权限。

每个 `Elf64_Phdr`结构体实例代表了`ELF`文件中程序头部表中的一个条目，描述了可执行文件在内存中各个段（`segment`）的加载信息。其中包含了段类型、段标志、段在文件中的偏移量、段在内存中的虚拟地址、段在文件中的大小等信息。

### p_type;        // 段类型

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_type`是一个字段，用于表示段的类型。它是一个`Elf64_Word`类型的无符号整数。

`p_type`字段的值定义了段的不同类型，常见的段类型包括：

+ `PT_NULL`：空段，没有任何内容或作用。
+ `PT_LOAD`：可加载段，包含可以被加载到内存中的数据或代码。
+ `PT_DYNAMIC`：动态链接信息段，包含动态链接器所需的信息。
+ `PT_INTERP`：解释器路径段，包含指定用于运行可执行文件的解释器路径。
+ `PT_NOTE`：注释段，包含与文件相关的附加信息。
+ `PT_PHDR`：程序头部表段，包含程序头部表的信息。
除了上述常见的段类型之外，还有其他类型的段用于表示特定的功能或特性。

通过读取程序头部表中每个条目的`p_type`字段，可以确定每个段的类型，并根据需要进行相应的处理和加载操作。

#### PT_LOAD
一个可执行文件至少有一个`PT_LOAD`类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或映射到内存中。
例如：一个动态链接的ELF可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）:
+ 存放程序代码的text段；
+ 存放全局变量和动态链接信息的data段；
上面的两个段将会被映射到内存中，并根据p_align中存放的值在内存中对齐。这个变量描述了段在文件和内存中的布局。

#### PT_DYNAMIC

动态段（`Dynamic Segment`）是 `ELF`（可执行和可链接格式）文件中的一种特殊类型的段，用于存储与动态链接相关的信息。动态段在程序头部表（`Program Header Table`）中通过`p_type`字段的值为`PT_DYNAMIC`来标识。

动态段的内容是一个动态链接器所需的动态信息表，其中包含了各种动态链接所需的符号、重定位、库加载等信息。这些信息在运行时由动态链接器处理，以完成动态链接过程。

动态段中的数据结构被称为动态段头表（`Dynamic Segment Header Table`），也被称为`DT`确定符（`DT_XXX`）数组。该表由多个连续的项组成，每个项都有两个成员：

+ `d_tag`：标签，表示该项的类型，例如`DT_SYMTAB`表示符号表地址，`DT_STRTAB`表示字符串表地址等。
+ `d_val`或`d_ptr`：具体的值或指针，表示与标签相关的数据。

动态段头表中的项以`NULL`结尾，即最后一项的`d_tag`的值为`0`，用于标识表的结束。

动态段提供了运行时动态链接所需的关键信息，使得操作系统或加载器能够在程序加载和运行时，根据需要加载库、解析符号并完成符号重定位等任务。

动态段是动态链接可执行文件所特有的，包含了动态链接所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：

+ 运行时需要链接的共享库列表
+ 全局偏移表`GOT`的地址
+ 重定向条目相关信息

动态段包含了一些结构体，在这些结构体中存放着与动态链接相关的信息。`d_tag`成员变量控制着`d_un`的含义。

`Elf64_Dyn` 是`ELF`（可执行和可链接格式）文件中动态段的数据结构，用于存储动态链接所需的信息。它是一个在`64`位系统上定义的结构体类型。

以下是`Elf64_Dyn`结构体的定义：
```c++
typedef struct {
    Elf64_Sxword d_tag; // 标签，表示该项的类型
    union {
        Elf64_Xword d_val; // 具体的值
        Elf64_Addr d_ptr;  // 具体的指针
    } d_un;
} Elf64_Dyn;
```
`d_tag`字段表示该项的类型，可以通过不同的标签值来识别不同的类型。常见的标签包括：

+ `DT_NULL`：表的结束标志。
+ `DT_NEEDED`：依赖的库名称。
+ `DT_STRTAB`：字符串表的地址。
+ `DT_SYMTAB`：符号表的地址。
+ `DT_REL` 或 `DT_RELA`：重定位表的地址。
+ `DT_INIT`：初始化函数的入口地址。
+ `DT_FINI`：终止函数的入口地址。
+ `DT_HASH`：哈希表的地址。
+ `DT_PLTGOT`：全局偏移表的地址。
+ `DT_DEBUG`：调试信息的入口地址。

`d_un` 联合体根据`d_tag`的不同类型存储具体的值或指针。如果标签是与数值相关的类型，则使用`d_val`成员存储；如果标签是与指针相关的类型，则使用`d_ptr`成员存储。

通过遍历动态段中的`Elf64_Dyn`结构体数组，可以获取动态链接所需的各种信息，如库依赖关系、符号表地址、重定位表地址等。这些信息在运行时由动态链接器（如 `ld.so`）使用，以完成动态链接和运行程序。

#### PT_PHDR
`PT_PHDR`段中保存了程序头本身的位置和大小。`Phdr`表中保存了所有的`Phdr`对文件（以及内存镜像）中段的描述信息。

可以使用 'readelf -l <filename>'命令查看文件的`Phdr`表：
```bash
❯ readelf -l libc++_shared.so

Elf file type is DYN (Shared object file)
Entry point 0x487b0
There are 8 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000d5a94 0x00000000000d5a94  R E    0x1000
  LOAD           0x00000000000d6018 0x00000000000d7018 0x00000000000d7018
                 0x00000000000080e0 0x000000000000b3e8  RW     0x1000
  DYNAMIC        0x00000000000dccf8 0x00000000000ddcf8 0x00000000000ddcf8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000200 0x0000000000000200 0x0000000000000200
                 0x0000000000000024 0x0000000000000024  R      0x4
  NOTE           0x00000000000d59fc 0x00000000000d59fc 0x00000000000d59fc
                 0x0000000000000098 0x0000000000000098  R      0x4
  GNU_EH_FRAME   0x00000000000bc000 0x00000000000bc000 0x00000000000bc000
                 0x0000000000003d14 0x0000000000003d14  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000d6018 0x00000000000d7018 0x00000000000d7018
                 0x0000000000007fe8 0x0000000000007fe8  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame_hdr .eh_frame .gcc_except_table .note.android.ident 
   01     .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 
   02     .dynamic 
   03     .note.gnu.build-id 
   04     .note.android.ident 
   05     .eh_frame_hdr 
   06     
   07     .init_array .fini_array .data.rel.ro .dynamic .got 
```

### p_flags;       // 段标志

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_flags`是一个字段，用于表示段的标志。它是一个`Elf64_Word`类型的无符号整数。

`p_flags`字段的值用于描述段的属性和特征。常见的段标志包括：

+ PF_X：可执行标志，表示该段包含可以被执行的代码。
+ PF_W：可写标志，表示该段可以被写入数据。
+ PF_R：可读标志，表示该段可以被读取数据。

其他自定义的标志，用于表示特定的段属性或特征。

通过读取程序头部表中每个条目的`p_flags`字段，可以确定每个段的标志，从而了解该段的访问权限和用途。根据需要，操作系统或加载器可以设置相应的内存保护和访问权限来控制对该段的读取、写入和执行操作。

### p_offset;      // 段在文件中的偏移量

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_offset`是一个字段，用于表示段在文件中的偏移量。它是一个 `Elf64_Off`类型的整数。

`p_offset`字段指示了该段在`ELF`文件中的起始位置相对于文件开头的偏移量。通过读取程序头部表中每个条目的 p_offset 字段，可以确定每个段在文件中的具体位置。这个偏移量可以用来定位和提取该段的内容。

加载器或操作系统可以使用 p_offset 字段将文件中的段加载到内存中的正确位置。通常，加载器会根据 p_offset 和其他相关信息，计算出正确的内存地址，并将段的内容从文件中读取到此地址处。

### p_vaddr;       // 段在内存中的虚拟地址

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_vaddr`是一个字段，用于表示段在内存中的虚拟地址。它是一个`Elf64_Addr`类型的整数。

`p_vaddr`字段指示了该段在内存中的起始虚拟地址。通过读取程序头部表中每个条目的`p_vaddr`字段，可以确定每个段在内存中的具体位置。

加载器或操作系统可以使用`p_vaddr`字段将段加载到正确的虚拟地址上。通常，加载器会将段的内容从文件中读取出来，并复制到分配给段的虚拟地址空间中。

为了使程序能够正常执行，段在内存中的虚拟地址需要满足对齐和访问权限等要求。加载器负责确保段被正确地加载到虚拟内存中，并设置适当的内存保护和访问权限。

### p_paddr;       // 段在物理内存中的物理地址（保留）

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_paddr`是一个字段，用于表示段在物理内存中的物理地址。它是一个`Elf64_Addr`类型的整数。

然而，需要注意的是，对于大多数操作系统和加载器，`p_paddr`字段通常被保留为空或没有实际使用。在现代计算机系统中，虚拟内存机制使得程序可以以虚拟地址的方式访问内存，而不需要显式地关注物理地址。

因此，大多数情况下，加载器会将段加载到合适的虚拟地址空间中，并不直接使用`p_paddr`字段所表示的物理地址。这意味着`p_paddr`字段往往没有被操作系统或加载器使用，而是保留给特定目标体系结构或特殊需求下可能使用的场景。

总之，`p_paddr`字段在一般情况下并不常用，且在大多数系统中被保留为空或不使用。

### p_filesz;      // 段在文件中的大小

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_filesz`是一个字段，用于表示段在文件中的大小。它是一个`Elf64_Xword`类型的无符号整数。

`p_filesz`字段指示了该段在 `ELF`文件中所占据的字节数。通过读取程序头部表中每个条目的`p_filesz`字段，可以确定每个段在文件中的确切大小。

加载器或操作系统在加载`ELF`文件时会使用`p_filesz`字段来确定要从文件中读取多少字节的数据来填充内存中的相应段。这样可以确保正确地将段的内容从文件加载到内存中，并避免超出文件大小或读取不足的问题。

需要注意的是，`p_filesz`可能小于或等于`p_memsz`字段，因为段在内存中的大小可能会包含一些额外的填充或对齐字节，而在文件中并没有实际存储。

### p_memsz;       // 段在内存中的大小

在`ELF`（可执行和可链接格式）文件的程序头部表中，`p_memsz`是一个字段，用于表示段在内存中的大小。它是一个`Elf64_Xword`类型的无符号整数。

`p_memsz`字段指示了该段在内存中所占据的字节数。通过读取程序头部表中每个条目的`p_memsz`字段，可以确定每个段在内存中的确切大小。

加载器或操作系统在加载`ELF`文件时会使用`p_memsz`字段来决定需要为该段分配多少内存空间。它可能大于或等于`p_filesz`字段，因为段在内存中的大小可能包括一些额外的填充、对齐字节或其他扩展所需的空间。

通过设置正确的`p_memsz`，加载器可以确保为段分配足够的内存空间以容纳段的内容，并正确地处理段之间的对齐要求。这样可以确保程序能够以正确的方式访问和执行内存中的各个段。

### p_align;       // 段在内存中的对齐方式

在`ELF`（可执行和可链接格式）文件的程序头部表中，p_align 是一个字段，用于表示段在内存中的对齐方式。它是一个`Elf64_Xword`类型的无符号整数。

`p_align`字段指示了段在内存中的对齐要求，即段在内存中的起始地址应该按照多少字节对齐。这个对齐值必须是2的幂次方，并且通常大于或等于段的大小。

加载器或操作系统会使用`p_align`字段来确保将段加载到满足对齐要求的内存地址上。如果段的对齐要求与加载器所能提供的合适起始地址不匹配，则可能需要进行填充或移动操作，以满足段的对齐要求。

通过设置正确的`p_align`，可以确保在加载和运行过程中，段按照预期的对齐方式被加载到内存中，避免了未对齐访问和性能问题。