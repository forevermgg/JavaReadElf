## Elf64_Shdr
`Elf64_Shdr`是`ELF`（`Executable and Linkable Format`）文件格式中的一个结构体，用于描述`64`位目标文件中的节区（`section`）头部信息。

`ELF`文件是一种常见的二进制文件格式，用于存储可执行文件、共享库和目标文件等。它定义了文件的结构和组织方式，包括头部信息、节区表、程序头部表和节区数据等。

`Elf64_Shdr`结构体定义如下：

```c++
typedef struct {
Elf64_Word      sh_name;        // 节区名称在节区名称表中的索引
Elf64_Word      sh_type;        // 节区类型
Elf64_Xword     sh_flags;       // 节区标志
Elf64_Addr      sh_addr;        // 节区的虚拟地址
Elf64_Off       sh_offset;      // 节区数据在文件中的偏移量
Elf64_Xword     sh_size;        // 节区数据的大小
Elf64_Word      sh_link;        // 链接到的节区的索引
Elf64_Word      sh_info;        // 附加信息
Elf64_Xword     sh_addralign;   // 节区数据的对齐方式
Elf64_Xword     sh_entsize;     // 节区中每个实体的大小
} Elf64_Shdr;
```
其中，各个字段的含义如下：

+ `sh_name`：节区名称在节区名称表中的索引。
+ `sh_type`：节区类型，定义了节区的作用和属性。
+ `sh_flags`：节区标志，描述了节区的属性和权限。
+ `sh_addr`：节区的虚拟地址，用于在内存中定位节区。
+ `sh_offset`：节区数据在文件中的偏移量，用于在文件中定位节区。
+ `sh_size`：节区数据的大小。
+ `sh_link`：链接到的节区的索引，用于建立节区之间的关联。
+ `sh_info`：附加信息，具体含义取决于节区类型。
+ `sh_addralign`：节区数据的对齐方式，通常是`2`的幂次方。
+ `sh_entsize`：节区中每个实体的大小，通常用于描述符号表等节区。

`Elf64_Shdr`结构体中的字段提供了对节区的描述和定位信息，有助于解析和操作`ELF`文件中的节区数据。

### sh_name;        // 节区名称在节区名称表中的索引
`sh_name`字段是一个`32`位的无符号整数，表示节区名称在节区名称表中的索引。`ELF`文件中的节区名称表是一个字符串表，用于存储节区的名称。

索引为`0`的名称表示无名称，其他索引值对应于节区名称表中的字符串偏移量。通过读取节区名称表中的字符串，可以获取到对应节区的名称。

例如，如果`sh_name`字段的值为5，那么对应的节区名称可以在节区名称表中找到字符串偏移量为`5`的位置，从那里开始读取字符串，直到遇到`null`终止符。

节区名称在`ELF`文件中是可选的，不是所有的节区都有名称。对于没有名称的节区，`sh_name`字段的值为`0`。
### sh_type;        // 节区类型
`sh_type`通常指文件格式、内存管理或数据结构中的段类型或节区类型。它描述了文件或内存区域中的特定节区或段的特征和用途。

例如，在可执行文件格式（如`ELF`，可执行和可链接格式）中，`sh_type`可以表示各种类型的节区，例如：

1. `SHT_NULL`：未定义的节区类型。
2. `SHT_PROGBITS`：程序数据。
3. `SHT_SYMTAB`：符号表。
4. `SHT_STRTAB`：字符串表。
5. `SHT_RELA`：带有加数的重定位条目。
6. `SHT_HASH`：符号哈希表。
7. `SHT_DYNAMIC`：动态链接信息。
8. `SHT_NOTE`：注释节区。
9. `SHT_NOBITS`：文件中不占用空间但具有大小的节区。
10. `SHT_REL`：不带加数的重定位条目。
11. `SHT_SHLIB`：保留。
12. `SHT_DYNSYM`：动态链接器符号表。

在内存管理或数据结构中，`sh_type`可能表示虚拟内存空间中的段类型，例如：

1. 文本段：包含可执行代码。
2. 数据段：包含已初始化和未初始化的数据。
3. 栈段：包含运行时堆栈数据。
4. 堆段：包含动态分配的内存。

#### .dynsym & .symtab 符号表
> 符号表记录了目标文件中所用到的所有符号信息，通常分为`.dynsym`和`.symtab`，前者是后者的子集。

+ `.dynsym`保存了引用自外部文件的符号，只能在运行时被解析

+ `.symtab`还保存了本地符号，用于调试和链接。

+ 目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项不具有实际的意义，它表示未定义的符号STN_UNDEF。每个符号都有一个符号值（`symbol value`），对于变量和函数，该值就是符号的地址。

##### 符号表项的格式定义（Elf64_Sym结构体）， 如下所示。
```c++
typedef struct
{
  Elf64_Word    st_name;        /* Symbol name (string tbl index) */
  unsigned char    st_info;        /* Symbol type and binding */
  unsigned char st_other;        /* Symbol visibility */
  Elf64_Section    st_shndx;        /* Section index */
  Elf64_Addr    st_value;        /* Symbol value */
  Elf64_Xword    st_size;        /* Symbol size */
} Elf64_Sym;
```
##### 字段意义
|字段|意义|
| ----------- | ----------- |
|st_name|符号的名字。但它并不是一个字符串，而是一个指向字符串表的索引值。如果此值为 0，那么此符号无名字。|
|st_info|符号的类型和属性。st_info 由一系列的比特位构成，标识了“符号绑定 (symbol binding)”、“符号类型(symbol type)”和“符号信息(symbol infomation)” 三种属性。|
|st_other|本数据成员目前暂未使用，在目标文件中一律赋值为 0。|
|st_shndx|任何一个符号表项的定义都与某一个“节”相联系，因为符号是为节而定 义，在节中被引用。本数据成员即指明了相关联的节。本数据成员是一个索引值， 它指向相关联的节在节头表中的索引。在重定位过程中，节的位置会改变，本数据 成员的值也随之改变，继续指向节的新位置。|
|st_value|符号的值。这个值其实没有固定的类型，它可能代表一个数值，也可以是一 个地址，具体是什么要看上下文。|
|st_size|符号的大小。各种符号的大小各不相同，比如一个对象的大小就是它实际占 用的字节数。如果一个符号的大小为 0 或者大小未知，则这个值为 0。|

###### st_value 
st_value 符号的值。这个值其实没有固定的类型，它可能代表一个数值，也可以是一 个地址，具体是什么要看上下文。

| 文件类型 | st_name | st_value的意义 |
| ---------------------- | ---------------- | ------------------------------------------------------------ |
| 重定位文件 | SHN_COMMON | 是这个节内容的字节对齐数 |
| 重定位文件 | 普通的字符串索引 | 该符号的起始地址在其所在节中的偏移量，而其所在的节的索引由st_shndx 给出 |
| 可执行文件和共享库文件 | 普通的字符串索引 | st_value 不再是一个节内的偏移量，而是一个虚拟地址，直接指向符号所在的内存位置 |

如果一个可执行文件中含有一个共享库文件函数的引用，那么那个共享目标文件的符号表应该含有这个 函数的符号。符号表的 st_shndx 成员值为 SHN_UNDEF，这就告诉了动态连接 器，这个函数的符号定义并不在可执行文件中。如果已经在可执行文件中给这个符 号申请了一个函数连接表项，而且符号表项的 st_value 成员不是 0，那么 st_value 值就将是函数连接表项中第一条指令的地址。否则，st_value 成员是 0。这个函数 连接表项地址被动态连接器用来解析函数地址。

###### st_info
st_info 符号的类型和属性。st_info 由一系列的比特位构成，标识了“符号绑定 (symbol binding)”、“符号类型(symbol type)”和“符号信息(symbol infomation)” 三种属性。下面几个宏分别用于读取这三种属性值。
```c++
#define ELF32_ST_BIND(i) ((i)>>4)
#define ELF32_ST_TYPE(i) ((i)&0xf)
#define ELF32_ST_INFO(b,t) (((b)<<4)+((t)&0xf))
```
+ 符号绑定
```
名字 | 值
STB_LOCAL | 0
STB_GLOBAL  | 1
STB_WEAK | 2
STB_LOPROC | 13
STB_HIPROC | 15
```
| 名字 | 值 | 意义 |
| ---------- | ---- | ------------------------------------------------------------ |
| STB_LOCAL | 0 | 表明本符号是一个本地符号。它只出现在本文件中，在本文件外该符号 无效。所以在不同的文件中可以定义相同的符号名，它们之间不会互相影 响。 |
| STB_GLOBAL | 1 | 表明本符号是一个全局符号。当有多个文件被连接在一起时，在所有文 件中该符号都是可见的。正常情况下，在一个文件中定义的全局符号，一 定是在其它文件中需要被引用，否则无须定义为全局。 |
| STB_WEAK | 2 | 类似于全局符号，但是相对于 STB_GLOBAL，它们的优先级更低。 全局符号(global symbol)和弱符号(weak symbol)在以下两方面有区别：<br />- 当连接编辑器把若干个可重定位目标文件连接起来时，同名的 STB_GLOBAL 符号不允许出现多次。而如果在一个目标文件中已经定义 了一个全局的符号(global symbol)，当一个同名的弱符号(weak symbol)出 现时，并不会发生错误。连接编辑器会以全局符号为准，忽略弱符号。与 全局符号相似，如果已经存在的是一个公用符号，即 st_shndx 域为 SHN_COMMON 值的符号，当一个同名的弱符号(weak symbol)出现时， 也不会发生错误。连接编辑器会以公用符号为准，忽略弱符号。<br />- 在查找符号定义时，连接编辑器可能会搜索存档的库文件。如 果是查找全局符号，连接编辑器会提取包含该未定义的全局符号的存档成 员，存档成员可能是一个全局的符号，也可能是弱符号；而如果是查找弱 符号，连接编辑器不会去提取存档成员。未解析的弱符号值为 0。 |
| STB_LOPROC | 13 | xxx |
| STB_HIPROC | 15 | xxx |

  + 符号类型

| 名字 | 值 | 意义 |
| ----------- | ---- | ------------------------------------------------------------ |
| STT_NOTYPE | 0 | 本符号类型未指定 |
| STT_OBJECT | 1 | 本符号是一个数据对象，比如变量、数组等 |
| STT_FUNC | 2 | 本符号是一个函数，或者其它的可执行代码。函数符号在共享目标文件 中有特殊的意义。当另外一个目标文件引用一个共享目标文件中的函数符 号时，连接编辑器为被引用符号自动创建一个连接表项。非 STT_FUNC 类型的共享目标符号不会通过这种连接表项被自动引用 |
| STT_SECTION | 3 | 本符号与一个节相关联，用于重定位，通常具有 STB_LOCAL 属性 |
| STT_FILE | 4 | 本符号是一个文件符号，它具有 STB_LOCAL 属性，它的节索引值是 SHN_ABS。在符号表中如果存在本类符号的话，它会出现在所有 STB_LOCAL 类符号的前部。 |
| STT_LOPROC | 13 | 这一区间的符号类型为特殊处理器保留 |
| STT_HIPROC | 15 | 这一区间的符号类型为特殊处理器保留 |
###### st_shndx 
任何一个符号表项的定义都与某一个“节”相联系，因为符号是为节而定 义，在节中被引用。本数据成员即指明了相关联的节。本数据成员是一个索引值， 它指向相关联的节在节头表中的索引。在重定位过程中，节的位置会改变，本数据 成员的值也随之改变，继续指向节的新位置。当本数据成员指向下面三种特殊的节 索引值时，本符号具有如下特别的意义：

| 值 | 意义 |
| -------------- | ------------------------------------------------------------ |
| 普通的节的索引 | 指明了相关联的节 |
| SHN_ABS | 符号的值是绝对的，具有常量性，在重定位过程中，此值不需要改变。 |
| SHN_COMMON | 本符号所关联的是一个还没有分配的公共节，本符号的值规定了其内容的 字节对齐规则，与 sh_addralign 相似。也就是说，连接器会为本符号分配存储 空间，而且其起始地址是向 st_value 对齐的。本符号的值指明了要分配的字 节数。 |
| SHN_UNDEF | 当一个符号指向第 1 节(SHN_UNDEF)时，表明本符号在当前目标文件中 未定义，在连接过程中，连接器会找到此符号被定义的文件，并把这些文件 连接在一起。本文件中对该符号的引用会被连接到实际的定义上去。 |



### sh_flags;       // 节区标志

`sh_flags`是在`Elf64_Shdr`结构体中定义的一个成员变量，用于表示节区的标志。

节区标志 (`sh_flags`) 用于描述节区的属性、权限或特征。它是一个存储在`ELF`文件中的无符号`64`位整数类型 (`Elf64_Xword`)。

具体来说，`sh_flags`可能包含一些预定义的标志位，例如：

+ SHF_WRITE：标识节区可写。
+ SHF_ALLOC：标识节区在内存中进行分配。
+ SHF_EXECINSTR：标识节区包含可执行指令。
+ SHF_MERGE：标识节区中的数据可以合并。
+ SHF_STRINGS：标识节区包含以 null 结尾的字符串。
  Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)

节区标志 (sh_flags) 相关的常见标志及其对应的含义：

+ W (write)：表示节区可写。可以在该节区进行写操作。
+ A (alloc)：表示节区在内存中进行分配。需要为该节区分配内存空间。
+ X (execute)：表示节区包含可执行指令。可以在该节区中执行代码。
+ M (merge)：表示节区中的数据可以合并。重复的数据将被合并为一个实体。
+ S (strings)：表示节区包含以 null 结尾的字符串。通常用于存储文本数据。
+ I (info)：表示该节区包含附加信息。
+ L (link order)：表示节区的链接顺序。
+ O (extra OS processing required)：表示需要进行额外的操作系统特定处理。
+ G (group)：表示节区属于一个组。
+ T (TLS)：表示节区用于线程局部存储 (Thread Local Storage)。
+ C (compressed)：表示节区中的数据已经被压缩。
+ x (unknown)：表示未知的节区标志位。
+ o (OS specific)：表示与特定操作系统相关的节区标志。
+ E (exclude)：表示该节区应该被排除在加载过程之外。
+ D (mbind)：表示节区用于内存绑定。
+ p (processor specific)：表示与特定处理器相关的节区标志。
这些标志位的具体含义可能会因应用程序、操作系统和上下文而有所不同。请注意，此列表可能不是详尽无遗的，实际使用时应参考相关文档和规范以获取准确的信息。
### sh_addr;        // 节区的虚拟地址，该节在内存中的虚拟地址，如果不加载到内存中，地址是0。

`sh_addr`是一个变量声明，它可能用于存储节区（`section`）的虚拟地址。在`ELF`文件格式中，每个节区都可以有一个虚拟地址，表示该节区在内存中的位置。

虚拟地址 (`sh_addr`) 是指程序在运行时使用的内存地址，与物理地址是分离的。节区的虚拟地址用于指定加载到内存中的节区应该被放置的位置。

具体来说，`sh_addr`可能存储了一个无符号`64`位整数值，代表某个节区的虚拟地址。

注意，节区是否有虚拟地址以及虚拟地址的具体值取决于链接器和操作系统的处理。对于某些特殊类型的节区（如`BSS`节区），虚拟地址可能为`0`或未定义。

### sh_offset;      // 节区数据在文件中的偏移量

`sh_offset`是一个变量声明，它可能用于存储节区（`section`）数据在文件中的偏移量。在`ELF`文件格式中，每个节区都有对应的数据，这些数据被存储在文件中的特定位置。

偏移量 (`sh_offset`) 是指从文件开头开始计算的字节偏移量，表示节区数据在`ELF`文件中的位置。通过该偏移量，可以在文件中定位并读取节区的数据。

具体来说，`sh_offset`可能存储了一个无符号`64`位整数值，表示某个节区的数据相对于文件开头的偏移量。

需要注意的是，不同的节区可能具有不同的偏移量，以便在文件中按顺序存储节区数据。此外，链接器和操作系统也会根据需要调整节区数据的对齐和布局方式。

### sh_size;        // 节区数据的大小

`sh_size`是一个变量声明，它可能用于存储节区（`section`）数据的大小。在`ELF`文件格式中，每个节区都包含一定数量的数据。

节区数据的大小 (`sh_size`) 是指该节区所包含数据的字节数量。通过这个值，可以确定需要读取或处理的节区数据的长度。

具体来说，`sh_size`可能存储了一个无符号`64`位整数值，表示某个节区的数据大小。

需要注意的是，不同的节区可能具有不同的数据大小，具体取决于节区类型和内容。链接器和编译器负责计算和设置节区数据的适当大小。

### sh_link;        // 链接到的节区的索引

`sh_link`是一个变量声明，它可能用于存储链接到的节区（`section`）的索引。在`ELF`文件格式中，某些节区可能需要与其他节区进行关联或链接。

链接到的节区的索引 (`sh_link`) 是指与当前节区相关联的另一个节区在节区表中的索引值。通过这个索引值，可以找到被链接的节区的位置和信息。

具体来说，`sh_link`可能存储了一个无符号`32`位整数值，表示链接到的节区在节区表中的索引。

需要注意的是，链接到的节区可以有不同的类型和用途，例如符号表节区 (`SHT_SYMTAB`) 可以链接到字符串表节区 (`SHT_STRTAB`) 来获取符号名称。

### sh_info;        // 附加信息
`sh_info`是一个变量声明，它可能用于存储节区（`section`）的附加信息。在`ELF`文件格式中，某些节区可以包含关于其他对象或属性的额外信息。

附加信息 (`sh_info`) 的具体含义取决于上下文和使用情况，因为不同的节区类型可能有不同的解释和用途。

一种常见的情况是，在符号表节区 (`SHT_SYMTAB`) 中，`sh_info`字段通常用于存储与该节区相关的本地符号表的索引。这个索引指向本地符号表中的第一个全局符号。

需要注意的是，`sh_info`字段的具体用途可以根据`ELF`文件的特定实现和应用程序的要求而有所不同。

### sh_addralign;   // 节区数据的对齐方式
`sh_addralign`是一个变量声明，它可能用于存储节区（`section`）数据的对齐方式。在`ELF`文件格式中，每个节区的数据可以按照特定的对齐规则进行存储。

节区数据的对齐方式 (`sh_addralign`) 是指节区数据在内存中的对齐要求。它表示在加载和访问节区数据时，需要将数据的起始地址按照指定的对齐方式进行对齐。

具体来说，`sh_addralign`可能存储了一个无符号`64`位整数值，表示某个节区数据的对齐要求。

通常情况下，对齐方式是一个以字节为单位的正整数值。例如，如果`sh_addralign`的值为`4`，则表示该节区数据在内存中需要按照`4`字节边界对齐。

对齐要求可以确保节区数据在内存中按照特定的对齐边界布局，提高访问效率和内存操作的性能。

### sh_entsize;     // 节区中每个实体的大小
`Elf64_Xword`是`ELF`文件格式中定义的一个数据类型，表示一个无符号`64`位整数。在`ELF`文件格式中，`sh_entsize`是一个与节区（`section`）相关的字段，用于表示每个实体的大小。

具体而言，`sh_entsize`可能是一个`Elf64_Xword`类型的变量，用于存储节区中每个实体的大小。这个值表示同一节区中每个实体所占据的字节数量。

例如，在符号表节区（`SHT_SYMTAB`）中，`sh_entsize` 表示每个符号条目的大小。在重定位节区（`SHT_RELA`或 `SHT_REL`）中，`sh_entsize`表示每个重定位项的大小。

需要注意的是，并非所有类型的节区都会使用`sh_entsize`字段，因此在某些情况下，该字段可能为0或无意义。

如果`sh_entsize`是 `Elf64_Xword`类型的变量，则它可以存储的最大值为` 2^64 - 1`，即 `18446744073709551615`。